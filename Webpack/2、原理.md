### webpack的作用

&emsp;&emsp;可以分为三点来说：

1. 模块打包
2. 编译兼容
3. 能力拓展

&emsp;&emsp;第一点，`webpack`将不同模块的文件打包到一起，同时保证了它们之间引用正确、执行有序。有了它做保障，我们就可以在开发阶段根据业务需要自由划分文件模块，保证项目结构的清晰、可读；

&emsp;&emsp;第二点，早期前端开发需要手写浏览器兼容代码，而`webpack`的`loader`机制，不仅可以帮助我们对代码进行`polyfill`，还可以编译转换`.less .vue .jsx`这些浏览器无法识别的文件，让我们在开发阶段可以使用新特性、新语法，提高开发效率；

&emsp;&emsp;第三点，利用`webpack`的`plugin`机制，在实现了模块打包、编译兼容的基础上，还能进一步实现诸如：按需加载、代码压缩等一系列功能，帮助我们进一步提高自动化程度、工程效率以及打包输出的质量。

---

### 简单的`webpack`打包流程

1. 读取`webpack`配置参数；
2. 启动`webpack`，创建`Compiler`对象，加载所有配置的`plugin`，执行对象的 **run** 方法，开始解析项目；
3. 从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；
4. 对不同文件类型的依赖模块文件使用对应的`loader`进行编译，最终转为`JavaScript`文件；（**注意**：`webpack`原生只能解析JavaScript文件）
5. 整个过程中，`webpack`会通过发布订阅模式，向外抛出一些`hooks`，而`webpack`的插件可以通过监听这些关键的事件节点，执行插件任务，从而达到干预输出结果的目的。

---

### 模块打包运行原理



---

### 常见loader

- `raw-loader`：加载文件原始内容（utf-8）
- `file-loader`：
- `url-loader`
- `source-map-loader`
- `svg-inline-loader`
- `image-loader`
- `json-loader`
- `handlebars-loader`
- `babel-loader`
- `ts-loader`
- `awesome-typescript-loader`
- `sass-loader`
- `css-loader`
- `style-loader`
- `postcss-loader`
- `eslint-loader`
- `tslint-loader`
- `mocha-loader`
- `coverjs-loader`
- `vue-loader`
- `i18n-loader`
- `cache-loader`

---

### 常见plugin

- `define-plugin`
- `ignore-plugin`
- `html-webpack-plugin`
- `web-webpack-plugin`
- `uglifyjs-webpack-plugin`
- `terser-webpack-plugin`
- `webpack-parallel-uglify-plugin`
- `mini-css-extract-plugin`
- `serviceworker-webpack-plugin`
- `clean-webpack-plugin`
- `ModuleConcatenationPlugin`
- `speed-measure-webpack-plugin`
- `webpack-bundle-analyzer`

---

### loader与plugin区别

&emsp;&emsp;1、`loader`本质是一个函数，在该函数中对接受到的内容进行转换，返回转换后的结果。由于`webpack`只能解析`JavaScript`，所以`loader`类似一个翻译官，对其他类型的文件、资源进行转译的预处理工作；

&emsp;&emsp;`plugin`是插件，基于事件流框架`Tapable`，插件可以拓展`webpack`功能，在`webpack`运行的生命周期中会广播出许多事件，`plugin`可以监听这些事件，在合适的时机通过`webpack`提供的`API`改变输出结果。

&emsp;&emsp;2、`loader`在`module.rules`中配置，作为模块的解析规则，类型为数组。每一项都是一个对象，内部包含了 test（类型文件）、loader、options（参数）等属性；

&emsp;&emsp;`plugin`在`plugins`中单独配置，类型为数组，每一项是一个`plugin`的实例，参数都通过构造函数传入。

---

### sourceMap

&emsp;&emsp;`sourceMap`是一项将编译、打包、压缩后的代码映射回源代码的技术。打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，在打包压缩的代码中`debug`会带来非常糟糕的体验，而`sourceMap`可以帮助我们快速定位到源代码的位置，提高开发效率。`sourceMap`并不是`webpack`特有的功能，而是`webpack`支持`sourceMap`。

---

### loader 及编写思路

&emsp;&emsp;已知`webpack`最后打包出来的成果是一份`JavaScript`代码，而它内部默认也只能处理`JavaScript`模块代码，在打包过程中会默认把所有遇到的文件都当作`JavaScript`代码进行解析。因此，当项目中存在非`JavaScript`类型的文件时，我们需要先对其进行必要的转换，才能继续执行打包任务，这就是`loader`机制。

&emsp;&emsp;常见的`loader`配置如下：

```javascript
module.exports = {
    module: {
        rules: [
            {
                text: /^your-regExp$/,
                use: [
                    {
                        loader: 'loader-name-A',
                    },
                    {
                        loader: 'loader-name-B',
                    }
                ]
            },
        ]
    }
}
```

&emsp;&emsp;通过配置可以看出，针对每个文件类型，`loader`支持以数组形式配置多个。`webpack`在转换该文件类型时，会按顺序链式调用每一个`loader`，前一个的返回内容将作为下一个的参数。

&emsp;&emsp;因此，`loader`开发需要遵循一些规范，比如返回值必须是标准的`JavaScript`代码字符串、开发上遵循“单一原则”只关心`loader`的输入以及对应的输出。

---

### Plugin及编写思路

&emsp;&emsp;上文已提过，`loader`主要负责文件类型的转换，而`plugin`负责功能的拓展。

&emsp;&emsp;`webpack`基于发布订阅模式，在运行的生命周期中会广播许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务，从而实现想要的功能。