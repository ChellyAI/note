## **浏览器的本地存储**

### **Cookie**

&emsp;&emsp;`Cookie` 最开始被设计出来并不是用作本地存储的，**而是为了弥补 `HTTP` 在状态管理上的不足**。

&emsp;&emsp;`HTTP` 协议是一个无状态协议，客户端向服务器发送请求，服务器返回响应，就到此为止了。但下次请求如何让服务端知道客户端是谁呢？`Cookie`应运而生。

&emsp;&emsp;`Cookie` 本质上是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储数据。向同一个域名下发送请求，都会携带相同的 `Cookie`，服务器拿到 `Cookie` 进行解析，拿到客户端的状态。

`Cookie` 的作用：
1. 会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）
2. 个性化设置（如用户自定义设置、主题等）
3. 浏览器行为跟踪（如跟踪分析用户行为等）

`Cookie` 的缺陷如下：
1. **容量缺陷**。体积上限只有<font color="red">**4 KB**</font>，只能用来存储少量的信息。
2. **性能缺陷**。`Cookie` 紧跟域名，不管域名下面的某一个地址需不需要这个 `Cookie`，请求都会带上完整的 `Cookie`，随着请求数变多，会造成巨大的性能浪费，因为请求携带了很多不必要的内容。
3. **安全缺陷**。因为 `Cookie` 以纯文本的形式在浏览器和服务器中进行传递，所以很容易被非法用户截获，然后经过篡改后，在 `Cookie` 的有效期内重新发送给服务器，这是十分危险的。另外，在 `HttpOnly` 为 **false** 的情况下，`Cookie` 信息能直接通过 `JavaScript` 脚本来读取。

---
### **localStorage**

&emsp;&emsp;跟 `Cookie` 相同的一点是针对一个域名，即同一个域名下，会存储相同的 `localStorage`。

&emsp;&emsp;与 `Cookie` 不同点如下：
1. **容量**。`localStorage` 的容量上限为 <font color="red">**5 M**</font>。
2. **只存在于客户端**。默认不参与和服务器的通信。这样就避免了 `Cookie` 的性能问题和安全问题。
3. **接口封装**。通过 `localStorage` 暴露在全局，通过它的 `setItem` 和 `getItem` 等方法进行操作，很方便。

#### 注意

&emsp;&emsp;`localStorage` 存储的都是字符串，所以存储对象需要使用 `JSON.stringfy` 方法，解析使用 `JSON.parse` 方法。利用其大容量和持久性，可以用来存储 `logo` 之类的图片 `Base64` 资源。

---
### **sessionStorage**

&emsp;&emsp;`sessionStorage` 与 `localStorage` 基本一致，但有一个本质区别，在于它只是会话级别的存储，不是持久化存储，会话结束，也就是页面关闭，它将不复存在。

#### 应用场景
1. 保存表单数据，保证页面刷新也不会丢失。
2. 保存本次浏览记录。如果关闭页面后不需要这些记录，就可以利用 `sessionStorage` 会话级别存储的特性去掉。（微博就是如此）。

---
### **IndexedDB**

&emsp;&emsp;`IndexedDB` 是运行在浏览器中的**非关系型数据库**，本质上就是一个数据库，理论上容量是没有上限的。

&emsp;&emsp;使用方法可以看[这里](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB)。

&emsp;&emsp;它的特性除了数据库本身的特性，例如：**支持事务**、**存储二进制数据**，还有如下需要注意：
1. **键值对存储**。其内部采用**对象仓库**存放数据，在这个对象仓库中数据采用键值对的方式来存储。
2. **异步操作**。数据库的读写数据 I/O 操作，浏览器中对异步 I/O 提供了支持。
3. **受同源策略限制，无法访问跨域数据库**。