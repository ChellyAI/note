# **浏览器安全问题**

## **CSRF攻击**

&emsp;&emsp;`CSRF`(Cross-site request forgery)跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

典型 `CSRF` 攻击具有如下流程：
1. 受害者登录 a.com，并保留了登录凭证(Cookie)
2. 攻击者引诱受害者访问 b.com
3. b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie
4. a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
5. a.com 以受害者名义执行了 act=xx
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作

### 解决方案

## **XSS攻击**

&emsp;&emsp;`XSS` ( Cross-Site Scripting ) 跨站攻击脚本（为了和 `CSS`区分开来，于是把第一个字母改成 `X`），是一种代码注入攻击。攻击者通过在目标网站注入恶意脚本，使之在用户的浏览器上运行。利用这些脚本，攻击者可获取用户的敏感信息如：Cookie、SessionID 等，进而危害数据安全。

&emsp;&emsp;`XSS` 攻击本质是恶意代码未经过滤，与网站正常代码混在一起，浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用信息冒充用户向网站发起攻击者定义的请求 。

&emsp;&emsp;根据攻击的来源，`XSS` 攻击可以分为：
- 存储型（持久型）
- 反射型（非持久型）
- `DOM` 型三种

### **1、存储型 XSS 攻击**

&emsp;&emsp;恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比后两者更大。存储型 `XSS` 攻击的有原因是没做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前没有做过滤；前端从服务端请求到数据，没有过滤。

**攻击步骤：**
1. 攻击者将恶意代码提交到目标网站的数据库中
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 `HTML` 中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户的行为，调用目标网站接口执行攻击者指定的操作

（传统RSA）HTTPS为什么让数据传输更安全
