## <a id="history">目录</a>
- [数据类型](#datatype)
- [类型判断](#datajudge)
- [类型转换](#datatransform)
- [间幕：JavaScript内存机制](#somethingelse)
- [浅拷贝](#clone)
- [深拷贝](#deepclone)
- [疑问](#question)

### <a id="datatype">一、数据类型</a>
&emsp;&emsp;JavaScript目前的数据类型有八种
- undefined
- null
- boolean
- number
- string
- object
- Symbol
- BigInt

1. `undefined`类型只有undefined这一个值，
```js
var uzi;
let xiaohu;
const mlxg; //  这里会直接报错，Missing initializer in const declaration，使用const需要一开始就赋值
//  var letme;
var ming;

//  下列值全部都是undefined
console.log(uzi, xiaohu, letme, ming);

console.log(uzi == ming, uzi === ming);// true, true

//  值得注意的是，letme并没有声明，直接使用会报错，但用typeof却会显示为undefined
console.log(typeof uzi);  //  undefined
console.log(typeof letme);  //  undefined
```

2. `null`类型同样只有null这一个值。从逻辑角度来看，null表示一个**空对象指针**，因此用typeof检测null会返回`object`。由于`undefined`是派生自`null`，因此在判断上会有如下的结果。
```js
const obj = null;
console.log(typeof obj);  //  "object"

console.log(undefined == null, undefined === null); //  true, false
```

**注意：**

&emsp;&emsp;目前而言`undefined`和`null`，null表示“没有对象”，此处不应该有值；undefined表示“缺少值”，此处应该有一个值，但并未定义。
```js
//  null用法
1、作为函数的参数，表示该函数的参数不是对象；
2、作为对象原型链的终点。

//  undefined用法
1、变量被声明但未赋值，此时等于undefined；
2、调用函数，应该传递的参数没有给，该参数就是undefined；
3、对象没有赋值的属性，该属性值为undefined；
4、函数没有返回值时，默认返回的是undefined。
```

3. `boolean`类型只有两个字面值，`true`和`false`，且区分大小写。所有类型的值都可以调用Boolean()函数获取一个Boolean值，返回内容取决于数据类型和实际的值，在某些控制语句中也会自动对内容进行Boolean转换，因此需要掌握具体转换结果，如下表所示：

| 数据类型 | 转换为true的值 | 转换为false的值 |
| --- | ------ | ---- |
| Boolean | true | false |
| String | 任何非空字符串 | ""（空字符串） |
| Number | 任何非零数字 | 0和NaN |
| Object | 任何对象 | null |
| Undefined | n/a或N/A | undefined |

4. `number`类型常见的是十进制，也可以使用八进制和十六进制来表示整数。八进制的数第一位必须是零，假如后面的数值超出了0~7的范围，将忽略开头的0，直接作为十进制来解析。十六进制前两位必须是0x，后面是十六进制数字（0~9及A~F，字母大小写无所谓）
```js
//  八进制
const octalNum1 = 070;  //  八进制的56
const octalNum2 = 079;  //  无效的八进制，解析为79

//  十六进制
const hexNum1 = 0xA;  //  十六进制的10
const hexNum2 = 0x1f; //  十六进制的31
```

### <a id="datajudge">二、类型的判断</a>



### <a id="datatransform">三、类型的转换</a>


### <a id="somethingelse">间幕一</a>
&emsp;&emsp;讲JavaScript的拷贝之前需要了解一下JavaScript的数据存储机制。  
&emsp;&emsp;JavaScript的存储空间分为栈(stack)、堆(heap)和池(一般也归类为栈)，其中栈存放变量，堆存放复杂对象，池存放常量。基础数据类型都有固定大小，它们由系统自动分配空间，可以直接操作保存在栈内存空间的值，因此**基础数据类型都是按值来访问的**；引用数据类型的大小不固定，他们的值是保存在堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，在操作对象时我们是在操作对象的引用，因此**引用类型的值是按照引用访问的**，可以理解为对象的地址指针。

### <a id="clone">四、浅拷贝</a>
&emsp;&emsp;根据以上分析可知，深浅拷贝是针对引用数据类型而言的，浅拷贝的如果是引用类型，拷贝的就是其内存地址，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**；深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，**且修改新对象不会影响原对象**

&emsp;&emsp;接下来介绍常见的赋值语句中属于浅拷贝的例子。

1. Object.assign()

&emsp;&emsp;Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。用法如下：
```js
const obj1 = {
    person: {
        name: "kobe",
        age: 41,
    },
    sports:'basketball',
};
const obj2 = Object.assign({}, obj1);

obj2.person.name = "wade";
obj2.sports = 'football'

console.log(obj1); // { person: { name: 'wade', age: 41 }, sports: 'basketball' }
```

2. lodash的clone方法

```js
import lodash from 'lodash';

const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};

const obj2 = lodash.clone(obj1);
console.log(obj1.b.f === obj2.b.f);// true
```
3. 展开运算符

```js
const obj1 = {
    name: 'Kobe',
    address: {
        x:100,
        y:100,
    },
};
const obj2 = {...obj1};

obj1.address.x = 200;
obj1.name = 'wade';

console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }
```

4. Array.prototype.concat()

```js
const arr1 = [1, 3, {username: 'kobe'}];
const arr2 = arr1.concat();    

arr2[2].username = 'wade';

console.log(arr1); //[ 1, 3, { username: 'wade' } ]
```
5. Array.prototype.slice()
```js
const arr = [1, 3, {username: ' kobe'}];
const arr3 = arr.slice();

arr3[2].username = 'wade';

console.log(arr); // [ 1, 3, { username: 'wade' } ]
```

### <a id="deepclone">五、深拷贝</a>



### <a id="question">疑问</a>

1. 直接赋值对于对象和数组而言，到底是浅拷贝还是深拷贝？

2. React使用过程中用同一state稍作修改后setState时是否需要拷贝？拷贝是深还是浅？（在线编辑实验手册以及某个studentList的地方碰到过类似问题）