## **目录**
- [防抖](#debounce)
  - [this的指向](#debounce-this)
  - [event对象](#debounce-event)
  - [立即执行](#debounce-immediate)
  - [返回值](#debounce-result)
  - [取消](#debounce-cancel)
- [hooks和防抖](#hooks-debounce)
- [节流](#throttle)

---
## <span id="debounce">**防抖**</span>

&emsp;&emsp;防抖的原理，就是在规定的时间内如果重复触发某一个事件，将以最后一次事件的时间为准，等待一定阈值的时间，这个时间内不再触发事件才会执行该任务。例如设定触发事件3s后再执行，倘若2.9秒的时候又触发了该事件，将从此刻重新计时，等待3s才会执行任务。

### **最简单的防抖函数**
```js
function debounce(func, delay = 50) {
    let timeoutId = 0;

    return function() {
        if(timeoutId) {
            clearTimeout(timeoutId);
        }

        timeoutId = setTimeout(func, delay);
    }
}
```
&emsp;&emsp;它利用了**setTimeout**和**闭包**这两个工具。

&emsp;&emsp;`setTimeout`函数有一个返回值`timeoutId`，它是一个正整数，表示了定时器的编号，将它传递给`clearTimeout()`可以取消该定时器。上面这个防抖函数的原理就是利用闭包记录了每次触发`func`的`timeoutId`，当重复触发后，会先将之前的定时器取消，然后新建一个延时为`delay`的定时器去执行`func`，这样就能保证`delay`期间只会执行一次。

&emsp;&emsp;使用时还需要**注意**别犯低级失误，确保每次调用的是同一个`debounce`函数，否则每次执行一个新的`debounce`会导致`timeoutId`永远都是新定义的0。
```js
//  错误方式，且执行结果是每次获取到一个返回的函数，并未执行那个函数
return (
  <button
    onClick={
      () => debounce(func, time);
    }
  >防抖</button>
)

//  正确方式
return (
  <button onClick={debounce(func, time)}>防抖</button>
)
```
### <span id="debounce-this">**this的指向**</span>

&emsp;&emsp;按照网上常见的文章描述（代码如下），
```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="IE=edge, chrome=1">
    <title>debounce</title>
    <style>
        #container{
            width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #444; font-size: 30px;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <script src="debounce.js"></script>
</body>

</html>
```
```js
var count = 1;
var container = document.getElementById('container');

function getUserAction() {
    container.innerHTML = count++;
    console.log(this);
};

function debounce(func, delay = 500) {
  let timeoutId = 0;

  return function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(func, delay);
  }
}

container.onmousemove = getUserAction;
```
&emsp;&emsp;在使用debounce后`this`指向会有变动，从未使用时的` <div id="container"></div> `变成了`window`对象，所以需要修改代码指向正确的this。
```js
function debounce(func, delay) {
  let timeoutId = 0;

  return function() {
    const context = this;

    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      func.apply(context);
    }, delay);
  }
};
```
### <span id="debounce-event">**event对象**</span>

&emsp;&emsp;事件处理函数总会有提供事件对象，正常情况下可以直接通过参数获取到这个对象：
```js
const handleClick = (e) => {
  conosle.log(e);
}
```
&emsp;&emsp;当使用`debounce`函数后会打印出`undefined`。因此需要将传参也一样添加到函数执行中去。
```js
function debounce(func, delay = 500) {
  let timeoutId = 0;

  return function(...args) {
    const context = this;

    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      func.apply(context, args)
    }, delay)
  }
}
```
### <span id="debounce-immediate">**立即执行**</span>

&emsp;&emsp;防抖函数也可以有另一种需求场景，立刻执行事件函数，等到停止触发n秒后才可以重新触发。此时可以添加一个参数`immediate`来区分两种需求场景。
```js
function debounce(func, delay = 500, immediate) {
  let timeoutId = 0;

  return function(...args) {
    const context = this;

    if (timeoutId) {
      clearTimeout(timeoutId);
    }

    if (immediate) {
      //  如果已经执行过，将不再执行
      let callNow = !timeoutId;

      timeoutId = setTimeout(() => {
        timeoutId = 0;
      }, delay);

      if (callNow) {
        func.apply(context, args);
      }
    }
    else {
      timeoutId = setTimeout(() => {
        func.apply(context, args);
      }, delay);
    }
  };
};
```
### <span id="debounce-result">**返回值**</span>

&emsp;&emsp;触发事件后执行的函数也可能会有返回值，但当不是立即执行的防抖函数时，使用了`setTimeout`，所以在将`func`返回值赋给变量并`return`的时候会一直是`undefined`，所以就只在立即执行的防抖中添加返回值。

（思考：非立即执行有没有什么办法能获取到返回值？）
```js
function debounce(func, delay = 500, immediate) {
  let timeoutId = 0;
  let result;

  return function(...args) {
    const context = this;

    if (timeoutId) {
      clearTimeout(timeoutId);
    }

    if (immediate) {
      let callNow = !timeoutId;

      timeoutId = setTimeout(() => {
        timeoutId = 0;
      }, delay);

      if (callNow) {
        result = func.apply(context, args);
      }
    }
    else {
      timeoutId = setTimeout(() => {
        func.apply(context, args);
      }, delay);
    }

    return result;
  }
}
```
### <span id="debounce-cancel">**取消**</span>

&emsp;&emsp;假如需要能够取消`debounce`函数，例如本来要等待10s才能再次触发，我想要通过点击某个按钮来取消防抖，达成立即执行。可以通过如下方法继续优化：
```js
function debounce(func, delay, immediate) {
  let timeoutId = 0;
  let result;

  const debounced = function() {
    const context = this;

    if (timeoutId) {
      clearTimeout(timeoutId);
    }

    if (immediate) {
      let callNow = !timeoutId;

      timeoutId = setTimeout(() => {
        timeoutId = 0;
      }, delay);

      if (callNow) {
        result = func.apply(context, args);
      }
    }
    else {
      timeoutId = setTimeout(() => {
        func.apply(context, args);
      }, delay);
    }

    return result
  };

  debounced.cancel = function() {
    clearTimeout(timeoutId);

    timeoutId = 0;
  }

  return debounced;
}
```
&emsp;&emsp;使用方法可如下：
```js
const handleDebounce = debounce(handleClick, 500, true);

return (
  <>
    <Button onClick={handleDebounce}>
      防抖
    </Button>
    <Button onClick={() => handleDebounce.cancel()}>
      取消防抖
    </Button>
  </>
)
```
---
## <span id="hooks-debounce">**hooks和防抖**</span>

&emsp;&emsp;`hooks`可以编写自定义函数，例如`useDebounce`。如何应用在`hooks`中需要做下尝试。

&emsp;&emsp;先给出一个测试用例：
```js
function test1(props) {
  const [counter, setCounter] = useState(0);

  const handleClick = useDebounce(() => {
    setCounter(counter + 1);
  }, 500);

  return (
    <>
      <Button onClick={handleClick}>防抖</Button>
      <div>{counter}</div>
    </>
  );
};
```

&emsp;&emsp;如果想当然地将防抖函数包装一下（如下）可能会有问题：
```js
function useDebounce(func, delay) {
  return debounce(func, delay);
};
```
&emsp;&emsp;为什么会有问题？换一个测试用例来看看：
```js
function test2(props) {
  const [counter1, setCounter1] = React.useState(0);
  const [counter2, setCounter2] = React.useState(0);

  const handleClick = useDebounce(() => {
    console.count('click1');
    setCounter1(counter1 + 1);
  }, 500);

  useEffect(() => {
    const timeoutId = setInterval(() => {
      setCounter2(x => x + 1);
    }, 500);

    return clearInterval.bind(undefined, timeoutId);
  }, []);

  return (
    <>
      <Button onClick={handleClick}>防抖</Button>
      <div>{counter1}</div>
      <div>{counter2}</div>
    </>
  );
}
```


---
## <span id="throttle">**节流**</span>

