## **目录**
- [new做了什么](#new)
- [一、原型链继承](#prototype)
- [二、借用构造函数继承（经典继承）](#constructor)
- [三、组合继承](#combine)
- [四、原型式继承](#prototype2)
- [五、寄生式继承](#parasitic)
- [六、寄生组合式继承](#anothercombine)

---
## <span id="new">**new做了什么**</span>

&emsp;&emsp;简单来说，new一个对象发生了如下的事情：
1. 创建一个新对象
2. 使新对象的原型指向构造函数
3. 改变构造函数的this指向新对象并运行
4. 返回这个新对象或构造函数运行的结果


&emsp;&emsp;首先给出一个父类
```js
function Person() {
  this.name = 'kobe';
  this.age = 16;
  this.wifves = {
    first: 'suzumiya haruhi',
    second: 'yukinoshita yukino',
    third: 'aisaka taiga',
  };
};

//  这里不能用箭头函数，因为需要使用this
Person.prototype.sayName = function() {
  console.log(this.name);
};
```
**注：在Person作为构造函数new出一个实例之前，内存中是不存在name和age的。**

---
## <span id="prototype">**一、原型链继承**</span>

&emsp;&emsp;原型链继承很简单，直接让实例的原型指向父类即可
```js
function Child() {

}

Child.prototype = new Person();
const child1 = new Child();
const child2 = new Child();

console.log(child1.name, child2.age); //  kobe 16
```
&emsp;&emsp;原型链继承的问题在于所有子类的实例都共用同一个**引用类型属性**，即此例中所有`child`都共用同一个`name`属性。当其中一个`child`修改其值后，所有其他子类也同样被修改。
```js
//  引用类型的修改
child1.wives.first = 'haruhi suzumiya';
console.log(child2.wives.first);  //  haruhi suzumiya

//  基础类型的修改
child1.name = 'gigi';
console.log(child2.name); //  kobe

//  child2的name属性依旧是kobe
//  因为此时child1.name是在child1实例内声明了一个name属性，其值为gigi
console.log(child1);  //  {name: 'gigi', __proto__: Person {name: 'kobe'}}

//  所以此时child2.name还是顺着原型链找到了通过Person生成的实例new Person()其中共有的name属性
```
&emsp;&emsp;还有一个问题在于创建`Child`实例时无法向`Person`传参。

---
## <span id="constructor">**二、借用构造函数继承（经典继承）**</span>

&emsp;&emsp;借用构造函数继承，是在`Child`方法中使用`call`调用`Person`，来达到生成父类相同属性的目的。**这种方式继承时，`Child`与`Person`并没有原型链上的联系**，所以实例无法通过原型链访问到父类定义的方法`sayName`。想要能够使用同样的方法，就只能把这些方法如同`name`、`wives`等属性一样，定义在父类的构造函数中。
```js
function Person(name) {
  this.name = name;
  this.age = 16;
  this.wifves = {
    first: 'suzumiya haruhi',
    second: 'yukinoshita yukino',
    third: 'aisaka taiga',
  };

  this.sayName = function() {
    console.log(this.name);
  };
}

function Child(name) {
  Person.call(this, name);
}

const child1 = new Child('caisiqi');
const child2 = new Child('csq');

child1.sayName(); //  'caisiqi'
child2.sayName(); //  'csq'
```
&emsp;&emsp;这种方法避免了**引用类型**被共享的问题，也可以通过`Child`向`Person`传参。

&emsp;&emsp;但缺点就是子类每次实例化都会创建一遍方法`sayName`，即每个`child`实例都有一个相同的`sayName`方法。为了更高的追求，相同且复用的方法最好能提取成公共方法。

---
## <span id="combine">**三、组合继承**</span>

&emsp;&emsp;组合继承方式结合了前两者的优点，利用原型链避免多次创建方法的问题；使用构造函数来定义各自的**引用属性**，避免共享的问题。
```js
function Person(name) {
  this.name = name;
  this.age = 16;
  this.wifves = {
    first: 'suzumiya haruhi',
    second: 'yukinoshita yukino',
    third: 'aisaka taiga',
  };
};

//  这里不能用箭头函数，因为需要使用this
Person.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, school) {
  Person.call(this, name);
  this.school = school;
}
//  将Child的原型指定为以Person为构造函数创建的实例
Child.prototype = new Person();
//  将constructor复位，否则constructor指向的是Person
//  不过我有个疑问，不复位又会有什么影响呢？复位有何意义？
Child.prototype.constructor = Child;

//
```



---
## <span id="prototype2">**四、原型式继承**</span>




---
## <span id="parasitic">**五、寄生式继承**</span>




---
## <span id="anothercombine">**六、寄生组合式继承**</span>


