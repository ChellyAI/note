### 数据存储机制
**（参考类型的间幕）**
### 内存的生命周期
- 内存分配
- 内存使用
- 内存回收

---
## **内存泄漏**

什么是内存泄漏？

**系统进程不再用到的内存，没有及时释放，就叫内存泄漏（memory leak）**

Chrome 限制浏览器所能使用的内存极限（64位为1.4GB，32位为1.0GB）

&emsp;&emsp;会造成内存泄漏的操作如下：
1. 意外的全局变量
2. 被遗忘的计时器或回调函数
3. 脱离 DOM 的引用
4. 闭包

&emsp;&emsp;情况一，可能因为使用未声明的变量，而意外创建了一个全局变量，使它一直留在内存中无法回收

&emsp;&emsp;情况二、设置了定时器，忘了取消，如果循环的函数有对外部变量的引用，就会导致那个变量一直留在内存中无法回收

&emsp;&emsp;情况三、获取了一个 DOM 元素的引用，而后面这个元素被删除了，由于一直保存对这个元素的引用，导致无法回收

&emsp;&emsp;情况四、不合理使用闭包，导致某些变量一直在内存中

**怎么观察内存泄漏**

用Chrome浏览器查看内存占用。
1. 打开开发者工具中的

**阮一峰内存泄漏评论区的精彩部分**
```
let arr = [1, 2, 3, 4];
console.log('hello world');
arr = null;

这段代码作为范例来说是不妥的，因为没有考虑函数的问题。

虽然理论上来说，不使用的变量需要清除，但在 js 的实际编程中大部分情况下不应当这样手动清除，而且一般的编程规范也不会建议这么做。

变量如果定义在函数内部，当函数运行完成后，这些内部变量就会完成它的生命周期，能够被垃圾回收，没有必要做手动清除。

变量如果定义在全局，那就不是需不需要清除的问题，而是首先要考虑有没有必要把变量定义在全局的问题。将临时变量定义在全局，这是需要纠正的一个不良习惯，纠正这种习惯的重要性要远远高于清除全局临时变量值的行为。

函数执行完毕后内部变量的值依然会被保留，这种情况当然也可能出现，也就是遇到了常说的“闭包”。对于闭包来说，并不是外层函数的所有变量都会被保留，引擎会进行优化，仅保留会在内层函数中引用的外层变量。那么问题就来了：既然形成闭包后，内层函数会用到的外层变量才会被保留，这样会被留下来继续保留引用的变量，就代表这些变量是有用的，为什么要清除它们呢？此外，对于在闭包内层函数中它自身定义的局部作用域的变量，这些局部变量一般情况下仍然是会完成其生命周期、被自动回收的。

总结来说：应尽量避免定义全局的临时变量，而函数内部仅涉及到本级作用域的变量（不会被闭包保留引用的）无需手动清除。对于全局公共变量、以及闭包内引用变量来说，仅在变量确实使用完毕、值不再需要保留时，才需要手动清除变量的值。

对于浏览器来说，还需要考虑 DOM 元素的情况。如果某个变量（以及对象类型变量上的属性、元素）保留了对于 DOM 元素的引用，包括引用本页的元素或同源的 iframe 内的元素等情况，当该元素在页面上被删除时，对于它的引用很可能还被保留在变量内，这样就会造成内存泄露。这视乎目标 DOM 元素是否易变的问题，不可一概而论，是复杂单页应用尤其要考虑的问题。对于易变的 DOM 元素，除了做一个公共的释放引用的方法外，也可以考虑不在变量上缓存对于 DOM 元素的引用、宁可牺牲一点点性能、每次都进行查询（现查现用）。这方面的平衡点需要根据实际情况来选择。
```
```
原文对于 WeakSet 和 WeakMap 的描述有点问题：“它们对于值的引用都是不计入垃圾回收机制的”。这里的“值”是不是应该改为“键”？

Map 体现为键/值对（ Set 则是键值一体）， WeakMap 只有对于键的引用是弱引用，对于其中值的引用则是强引用。

当然，这段原文中所提到的“值”与“键/值对”中的“值”很可能不是指同一个概念，所以也不能说它是完全错误的，但毕竟表述不严谨，可能引起误解。或许原文换一种表述方式会更妥当些，例如“在 WeakSet 的值和 WeakMap 的键上对于对象的引用都是弱引用，都是不计入垃圾回收机制的”。
```

---
## **V8引擎垃圾回收机制**

&emsp;&emsp;v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。

&emsp;&emsp;新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

&emsp;&emsp;新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：
1. 首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。

2. 如果对象不存活，则释放对象的空间。

3. 最后将 From 空间和 To 空间角色进行交换。

新生代对象晋升到老生代有两个条件：

- 第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

- 第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。

&emsp;&emsp;老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。

&emsp;&emsp;由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。
