TCP报文头部结构
## 目录
- [三次握手](#catch)
- [四次挥手](#shake)
- [为什么](#why)
- [TCP和UDP的区别](#tcp-udp)

---
## <span id="catch">**三次握手**</span>

1. 客户端向服务端发送连接请求报文，该报文段中包含自身的数据通信初始序号，请求后，客户端进入**SYN-SENT**状态
2. 服务端收到请求后，如果同意连接，会发送一个应答，该应答中也会包含自身数据通信的初始序号。发送完成后服务端进入**SYN-RECEIVED**
3. 当客户端收到来自服务端同意连接的应答后，向服务端发送一个确认报文。客户端发送完这个报文后进入**ESTABLISHED**状态，服务端收到确认后也进入**ESTABLISHED**状态，连接建立成功


---
## <span id="shake">**四次挥手**</span>

1. 客户端A认为数据已经发送完成，向服务端B发送连接释放请求
2. 服务端B收到连接释放请求后，告诉应用层释放TCP链接，然后发送ACK包并进入**CLOSE-WAIT**状态，此时表明A到B的连接已经释放，不再接收A的数据，但可以继续想A发送数据
3. B发送完数据后，向A发送连接释放请求，然后进入**LAST-ACK**状态。通过延迟确认的技术，（通常由时间限制，否则对方会认为需要重传）可以将2、3合并，延迟ACK包的发送
4. A收到B的连接释放请求后，向B发送确认应答，随后进入**TIME-WAIT**状态。该状态会持续2MSL（最大段生存期，指报文在网络中生存的时间，超时会被抛弃），若该时间内没有收到B的重发请求的话，进入**CLOSED**状态。B收到确认应答后进入**CLOSED**状态。

---
## <span id="why">**为什么**</span>

### **问题一：为什么要三次握手，而不是两次握手？（为什么客户端要再次发送确认报文）**

&emsp;&emsp;这是为了确认在即将建立连接时，两端都处于准备建立连接的状态，防止失效的连接请求报文被服务器接收而产生错误。

&emsp;&emsp;假设客户端发送请求连接报文A，因为网络原因超时，此时TCP启动超时重传机制，再次发送连接请求报文B，顺利到达服务端并建立连接。结束连接后，服务端又收到报文A，此时若不同客户端确认，直接进入**ESTABLISHED**状态并发送同意连接报文至客户端，而客户端已经处于**CLOSED**状态，因此连接不会建立且服务端一直处于等待状态，造成资源浪费。

&emsp;&emsp;举个例子，两个人发微信聊天，如果A对B说“听得到吗”，B回复A“听得到”，正常情况下这两次交流就可以确认并开始互发消息。但假如第一次A问“听得到吗”的时候在隧道内，导致消息并未及时发出去，而A就把微信关闭了，当B接收到A后回复一句“听得到”并做好准备聊天，导致空等。而如果A收到B的回复后再回一句“好的好的，咱开始吧”，让B知道A现在也准备好了，加一道保险，更加安全。

### **问题二：为什么连接的时候是三次握手，关闭时候却是四次挥手？**

&emsp;&emsp;关闭连接时，服务器收到对方的**FIN**报文时，仅仅表示对方不再发送数据了，但是还能接收数据，而自己也未必全部数据都发送给对方了。于是己方可以立即关闭，也可以发送一些数据给对方后，再发送**FIN**报文给对方来表示同意现在关闭连接。因此己方的**ACK**和**FIN**会分开发送，导致多了一次。




### **问题三：为什么A要进入TIME-WAIT状态，等待2MSL后再进入CLOSED状态？**

&emsp;&emsp;为了保证B能收到A的确认应答。

&emsp;&emsp;假如A发完确认应答后直接进入**CLOSED**状态，如果因为网络问题造成B未收到应答，会导致B不能正常关闭。

---
## <span id="tcp-udp">**TCP和UDP的区别**</span>

